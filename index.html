<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Happy New Year ✦</title>

  <style>
    :root {
      --bg: #000;
      --fg: #fff;
      --muted: rgba(255,255,255,0.72);
      --grid-gap: 20px;
      --max: 1100px;
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--fg);
      font-family: Helvetica, Arial, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      overflow: hidden;
    }

    /* Three.js neon background */
    #bg3d {
      position: fixed;
      inset: 0;
      z-index: 0;
    }

    /* subtle film grain */
    .grain {
      position: fixed;
      inset: 0;
      z-index: 1;
      pointer-events: none;
      opacity: 0.15;
      background-image:
        url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='160' height='160'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.8' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='160' height='160' filter='url(%23n)' opacity='.35'/%3E%3C/svg%3E");
      background-size: 220px 220px;
      mix-blend-mode: overlay;
      animation: grainMove 7s steps(8) infinite;
    }
    @keyframes grainMove {
      0% { transform: translate3d(0,0,0); }
      25% { transform: translate3d(-8px,6px,0); }
      50% { transform: translate3d(6px,-10px,0); }
      75% { transform: translate3d(12px,8px,0); }
      100% { transform: translate3d(0,0,0); }
    }

    /* Confetti canvas on top */
    #confetti {
      position: fixed;
      inset: 0;
      z-index: 3;
      pointer-events: none;
    }

    /* Swiss grid content */
    .wrap {
      position: relative;
      z-index: 2;
      height: 100%;
      display: grid;
      place-items: start;
      padding: 28px;
      overflow: auto;
    }

    .grid {
      width: 100%;
      max-width: var(--max);
      display: grid;
      grid-template-columns: repeat(12, 1fr);
      gap: var(--grid-gap);
      align-content: start;
      padding-top: 8px;
    }

    /* Thin grid lines for brutalist/swiss feel */
    .grid::before {
      content: "";
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 2;
      opacity: 0.06;
      background:
        linear-gradient(to right, rgba(255,255,255,0.7) 1px, transparent 1px),
        linear-gradient(to bottom, rgba(255,255,255,0.7) 1px, transparent 1px);
      background-size: 80px 80px;
      mix-blend-mode: screen;
    }

    .left {
      grid-column: 1 / 8;
      min-width: 0;
    }

    .right {
      grid-column: 8 / 13;
      min-width: 0;
      align-self: start;
    }

    @media (max-width: 860px) {
      .left, .right { grid-column: 1 / 13; }
      .wrap { padding: 18px; }
    }

    h1 {
      margin: 0;
      font-weight: 700;
      letter-spacing: -0.03em;
      line-height: 0.95;
      font-size: clamp(44px, 6vw, 84px);
      text-transform: uppercase;
    }

    .sub {
      margin-top: 14px;
      font-size: 16px;
      line-height: 1.55;
      color: var(--muted);
      max-width: 55ch;
    }

    .meta {
      margin-top: 22px;
      display: grid;
      gap: 10px;
      font-size: 14px;
      color: rgba(255,255,255,0.78);
    }

    .meta .row {
      display: flex;
      gap: 10px;
      align-items: baseline;
      flex-wrap: wrap;
    }
    .label {
      opacity: 0.7;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      font-size: 12px;
    }
    .value {
      font-weight: 700;
      letter-spacing: 0.02em;
    }

    /* Brutalist neon accent line */
    .rule {
      margin-top: 24px;
      height: 2px;
      width: min(520px, 100%);
      background: rgba(255,255,255,0.75);
      position: relative;
      overflow: hidden;
    }
    .rule::after {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(90deg, transparent, rgba(0,255,255,0.9), rgba(255,0,255,0.9), transparent);
      transform: translateX(-120%);
      animation: scan 2.4s linear infinite;
      mix-blend-mode: screen;
      opacity: 0.9;
    }
    @keyframes scan {
      0% { transform: translateX(-120%); }
      100% { transform: translateX(120%); }
    }

    /* Right column — “instructions” area */
    .note {
      margin-top: 8px;
      font-size: 13px;
      line-height: 1.6;
      color: rgba(255,255,255,0.72);
    }

    .hint {
      margin-top: 14px;
      padding-top: 14px;
      border-top: 1px solid rgba(255,255,255,0.18);
      font-size: 13px;
      line-height: 1.6;
      color: rgba(255,255,255,0.72);
    }

    .kbd {
      display: inline-block;
      padding: 2px 8px;
      border: 1px solid rgba(255,255,255,0.25);
      border-radius: 999px;
      font-size: 12px;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: rgba(255,255,255,0.85);
    }

    /* Small corner signature */
    .corner {
      position: fixed;
      bottom: 18px;
      left: 28px;
      z-index: 2;
      font-size: 12px;
      letter-spacing: 0.14em;
      text-transform: uppercase;
      color: rgba(255,255,255,0.55);
      user-select: none;
    }

    /* Prevent selection glow weirdness on mobile */
    ::selection { background: rgba(255,255,255,0.22); }
  </style>
</head>

<body>
  <canvas id="bg3d"></canvas>
  <div class="grain"></div>
  <canvas id="confetti"></canvas>

  <div class="wrap">
    <div class="grid">
      <section class="left">
        <h1 id="title">Happy New Year</h1>
        <div class="rule"></div>

        <p class="sub" id="message">
          Wishing you a clean start, loud momentum, and a year that actually feels like yours.
          Move your mouse — let it rain.
        </p>

        <div class="meta">
          <div class="row">
            <span class="label">To</span>
            <span class="value" id="toName">Friend</span>
          </div>
          <div class="row">
            <span class="label">From</span>
            <span class="value" id="fromName">Ingsa</span>
          </div>
          <div class="row">
            <span class="label">Year</span>
            <span class="value" id="year"></span>
          </div>
        </div>
      </section>

      <aside class="right">
        <div class="note">
          <span class="label">Interaction</span><br/>
          Confetti follows your cursor. Neon system runs underneath like a quiet club in the walls.
        </div>

        <div class="hint">
          <span class="label">Personalize</span><br/>
          Add <span class="kbd">?to=Name</span> and optionally <span class="kbd">&from=YourName</span><br/>
          Example: <span class="kbd">?to=Alex&from=Ingsa</span>
        </div>

        <div class="hint">
          <span class="label">Secret</span><br/>
          Press <span class="kbd">C</span> to trigger a confetti burst.
        </div>
      </aside>
    </div>
  </div>

  <div class="corner">NEW YEAR CARD / BLACK–WHITE / NEON FIELD</div>

  <!-- Three.js (CDN) -->
  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

    // -----------------------------
    // Personalization via URL params
    // -----------------------------
    const params = new URLSearchParams(location.search);
    const to = params.get("to")?.trim();
    const from = params.get("from")?.trim();
    const msg = params.get("msg")?.trim();

    document.getElementById("year").textContent = String(new Date().getFullYear());
    if (to) document.getElementById("toName").textContent = to;
    if (from) document.getElementById("fromName").textContent = from;
    if (msg) document.getElementById("message").textContent = msg;

    // -----------------------------
    // Neon Three.js background
    // -----------------------------
    const canvas = document.getElementById("bg3d");
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(55, 1, 0.1, 100);
    camera.position.set(0, 0, 6);

    // Subtle fog for depth
    scene.fog = new THREE.FogExp2(0x000000, 0.14);

    // Additive glowing points
    const starCount = 1600;
    const positions = new Float32Array(starCount * 3);
    const colors = new Float32Array(starCount * 3);

    // Neon palette
    const palette = [
      new THREE.Color("#00ffff"), // cyan
      new THREE.Color("#ff00ff"), // magenta
      new THREE.Color("#7cff00"), // acid green
      new THREE.Color("#00a3ff"), // electric blue
      new THREE.Color("#ff3b3b"), // neon red
    ];

    for (let i = 0; i < starCount; i++) {
      const i3 = i * 3;
      // Spread in a loose volume
      positions[i3 + 0] = (Math.random() - 0.5) * 14;
      positions[i3 + 1] = (Math.random() - 0.5) * 8;
      positions[i3 + 2] = (Math.random() - 0.5) * 12;

      const c = palette[(Math.random() * palette.length) | 0];
      colors[i3 + 0] = c.r;
      colors[i3 + 1] = c.g;
      colors[i3 + 2] = c.b;
    }

    const geom = new THREE.BufferGeometry();
    geom.setAttribute("position", new THREE.BufferAttribute(positions, 3));
    geom.setAttribute("color", new THREE.BufferAttribute(colors, 3));

    const mat = new THREE.PointsMaterial({
      size: 0.045,
      vertexColors: true,
      transparent: true,
      opacity: 0.85,
      blending: THREE.AdditiveBlending,
      depthWrite: false
    });

    const points = new THREE.Points(geom, mat);
    scene.add(points);

    // Energy planes (soft neon gradients)
    function makePlane(colorA, colorB, y, speed) {
      const planeGeo = new THREE.PlaneGeometry(14, 3, 1, 1);
      // Simple shader-ish look via MeshBasic + vertex colors gradient
      const planeColors = new Float32Array(4 * 3);
      const ca = new THREE.Color(colorA);
      const cb = new THREE.Color(colorB);
      // top two vertices A, bottom two vertices B
      // PlaneGeometry vertex order depends, but gradient will still read as a band
      for (let v = 0; v < 4; v++) {
        const isTop = v < 2;
        const cc = isTop ? ca : cb;
        planeColors[v * 3 + 0] = cc.r;
        planeColors[v * 3 + 1] = cc.g;
        planeColors[v * 3 + 2] = cc.b;
      }
      planeGeo.setAttribute("color", new THREE.BufferAttribute(planeColors, 3));

      const planeMat = new THREE.MeshBasicMaterial({
        vertexColors: true,
        transparent: true,
        opacity: 0.10,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        side: THREE.DoubleSide
      });

      const mesh = new THREE.Mesh(planeGeo, planeMat);
      mesh.position.set(0, y, -2.2);
      mesh.userData.speed = speed;
      scene.add(mesh);
      return mesh;
    }

    const band1 = makePlane("#00ffff", "#ff00ff", 1.7, 0.35);
    const band2 = makePlane("#7cff00", "#00a3ff", -1.4, 0.28);

    // Mouse parallax
    let mx = 0, my = 0;
    window.addEventListener("mousemove", (e) => {
      const nx = (e.clientX / innerWidth) * 2 - 1;
      const ny = (e.clientY / innerHeight) * 2 - 1;
      mx = nx;
      my = ny;
    });

    function resize() {
      const w = innerWidth;
      const h = innerHeight;
      renderer.setSize(w, h, false);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    }
    window.addEventListener("resize", resize);
    resize();

    const clock = new THREE.Clock();

    function animate() {
      const t = clock.getElapsedTime();

      // Parallax drift
      camera.position.x = THREE.MathUtils.lerp(camera.position.x, mx * 0.35, 0.06);
      camera.position.y = THREE.MathUtils.lerp(camera.position.y, -my * 0.22, 0.06);
      camera.lookAt(0, 0, 0);

      // Slow swirl
      points.rotation.y = t * 0.08;
      points.rotation.x = Math.sin(t * 0.22) * 0.06;

      // Move energy bands horizontally (wrap)
      for (const band of [band1, band2]) {
        band.position.x = ((t * band.userData.speed) % 6) - 3;
        band.rotation.z = Math.sin(t * 0.9) * 0.05;
      }

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate();

    // -----------------------------
    // Confetti (mouse-follow)
    // -----------------------------
    const confCanvas = document.getElementById("confetti");
    const ctx = confCanvas.getContext("2d");

    function resizeConf() {
      confCanvas.width = Math.floor(innerWidth * Math.min(devicePixelRatio, 2));
      confCanvas.height = Math.floor(innerHeight * Math.min(devicePixelRatio, 2));
      confCanvas.style.width = innerWidth + "px";
      confCanvas.style.height = innerHeight + "px";
      ctx.setTransform(Math.min(devicePixelRatio, 2), 0, 0, Math.min(devicePixelRatio, 2), 0, 0);
    }
    window.addEventListener("resize", resizeConf);
    resizeConf();

    const pieces = [];
    const neon = ["#00ffff", "#ff00ff", "#7cff00", "#00a3ff", "#ff3b3b"];

    function spawnConfetti(x, y, amount = 18, force = 1) {
      for (let i = 0; i < amount; i++) {
        const angle = (Math.random() * Math.PI * 2);
        const speed = (2 + Math.random() * 5) * force;

        pieces.push({
          x, y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed - (2.2 * force),
          g: 0.16 + Math.random() * 0.07,
          r: 2 + Math.random() * 4,
          a: 1,
          spin: (Math.random() - 0.5) * 0.4,
          rot: Math.random() * Math.PI,
          color: neon[(Math.random() * neon.length) | 0],
          life: 70 + (Math.random() * 40) | 0
        });
      }
    }

    let last = { x: innerWidth * 0.5, y: innerHeight * 0.4 };
    window.addEventListener("mousemove", (e) => {
      const dx = e.clientX - last.x;
      const dy = e.clientY - last.y;
      const dist = Math.hypot(dx, dy);
      if (dist > 10) {
        spawnConfetti(e.clientX, e.clientY, Math.min(24, 8 + (dist / 8) | 0), 0.75);
        last = { x: e.clientX, y: e.clientY };
      }
    }, { passive: true });

    window.addEventListener("keydown", (e) => {
      if (e.key.toLowerCase() === "c") {
        spawnConfetti(innerWidth * 0.35, innerHeight * 0.42, 220, 1.3);
      }
    });

    function tickConfetti() {
      ctx.clearRect(0, 0, innerWidth, innerHeight);

      for (let i = pieces.length - 1; i >= 0; i--) {
        const p = pieces[i];
        p.vy += p.g;
        p.x += p.vx;
        p.y += p.vy;
        p.rot += p.spin;
        p.life -= 1;
        p.a = Math.max(0, p.life / 110);

        // wrap-ish drift
        if (p.y > innerHeight + 80 || p.x < -80 || p.x > innerWidth + 80 || p.a <= 0) {
          pieces.splice(i, 1);
          continue;
        }

        ctx.save();
        ctx.globalAlpha = p.a;
        ctx.translate(p.x, p.y);
        ctx.rotate(p.rot);

        // little neon glow
        ctx.shadowBlur = 14;
        ctx.shadowColor = p.color;
        ctx.fillStyle = p.color;

        // confetti “chip”
        ctx.fillRect(-p.r, -p.r * 0.6, p.r * 2.2, p.r * 1.1);

        ctx.restore();
      }

      requestAnimationFrame(tickConfetti);
    }
    tickConfetti();
  </script>
</body>
</html>
